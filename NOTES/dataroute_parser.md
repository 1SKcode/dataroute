# DataRoute Parser - Документация

## Введение

DataRoute Parser - это компонент для парсинга и интерпретации DSL (предметно-ориентированного языка),
предназначенного для описания маршрутов данных между источниками и целями. Парсер трансформирует
текстовое представление маршрутов в структурированное JSON-представление, которое может использоваться
для дальнейшей обработки данных.

## Принцип работы и архитектура

```
┌─────────────────┐      ┌───────────────┐      ┌───────────────┐      ┌───────────────┐
│  Исходный DSL   │ ───> │    Лексер     │ ───> │    Парсер     │ ───> │  Посетитель   │
│     (текст)     │      │ (токенизация) │      │ (создание AST)│      │(генераторJSON)│
└─────────────────┘      └───────────────┘      └───────────────┘      └───────────────┘
         │                      │                      │                      │
         │                      ▼                      ▼                      ▼
         │                ┌───────────────┐      ┌───────────────┐      ┌──────────────┐
         │                │ Список токенов│      │  Абстрактное  │      │  Конечный    │
         └───────────────>│  и их типов   │─────>│синтаксическое │─────>│  результат   │
                          │               │      │   дерево (AST)│      │    (JSON)    │
                          └───────────────┘      └───────────────┘      └──────────────┘
```

### Процесс обработки DSL

1. **Лексический анализ (Lex y66y er)**:
   - Разбивает входной текст на токены
   - Идентифицирует типы токенов (источник, цель, маршрут и т.д.)
   - Извлекает значения из токенов

2. **Синтаксический анализ (Parser)**:
   - Создает абстрактное синтаксическое дерево (AST)
   - Организует токены в иерархическую структуру
   - Выполняет проверку структуры

3. **Генерация JSON (Visitor)**:
   - Обходит AST
   - Создает JSON-представление
   - Применяет бизнес-логику

## Компоненты системы

### 1. Перечисления (Enums)

```
┌───────────────┐     ┌───────────────┐     ┌───────────────────┐
│   TokenType   │     │   NodeType    │     │  PipelineItemType │
├───────────────┤     ├───────────────┤     ├───────────────────┤
│    SOURCE     │     │    PROGRAM    │     │      PY_FUNC      │
│    TARGET     │     │    SOURCE     │     │      DIRECT       │
│ ROUTE_HEADER  │     │    TARGET     │     │     CONDITION     │
│  ROUTE_LINE   │     │  ROUTE_BLOCK  │     │       EVENT       │
│   CONDITION   │     │  ROUTE_LINE   │     └───────────────────┘
│     EVENT     │     │   PIPELINE    │
└───────────────┘     │   FIELD_SRC   │
                      │   FIELD_DST   │
                      │   CONDITION   │
                      │     EVENT     │
                      │   FUNC_CALL   │
                      │  DIRECT_MAP   │
                      └───────────────┘
```

### 2. Базовые классы

```
┌───────────────┐
│    Token      │
└───────────────┘
        ▲
        │
        │
┌───────────────┐     ┌───────────────┐     ┌───────────────────┐
│    ASTNode    │<────│  ASTVisitor   │     │DataSourceStrategy │
├───────────────┤     ├───────────────┤     ├───────────────────┤
│  node_type    │     │visit_program()│     │   read_field()    │
│   accept()    │     │visit_source() │     └───────────────────┘
└───────────────┘     │visit_target() │              ▲
        ▲             │      ...      │              │
        │             └───────────────┘              │
        │                     ▲                      │
┌──────────────────────┐      │              ┌──────────────────┐
│   Конкретные узлы    │      │              │ Стратегии чтения │
│   (ProgramNode,      │      │              │ (DictStrategy,   │
│    SourceNode,       │      │              │  ListStrategy)   │
│    TargetNode...)    │      │              └──────────────────┘
└──────────────────────┘      │
                              │
                      ┌───────────────────┐
                      │ JSONGenerator     │
                      │ (конкретный       │
                      │  посетитель)      │
                      └───────────────────┘
```

### 3. Основные компоненты обработки

```
┌───────────────┐      ┌───────────────┐      ┌────────────────┐
│     Lexer     │───┬─>│    Parser     │───┬─>│ JSONGenerator  │
├───────────────┤   │  ├───────────────┤   │  ├────────────────┤
│  tokenize()   │   │  │    parse()    │   │  │ visit_*()      │
└───────────────┘   │  └───────────────┘   │  └────────────────┘
        ▲           │          ▲           │          ▲
        │           │          │           │          │
        │           │          │           │          │
        │           │          │           │          │
┌───────────────────────────────────────────────────────────────┐
│                      DataRouteParser                          │
├───────────────────────────────────────────────────────────────┤
│                         parse()                               │
└───────────────────────────────────────────────────────────────┘
```

## Описание синтаксиса DSL

```
# Определение источника данных
sourse=dict

# Определение целей (мест назначения данных)
target1=dict("target_name")
target2=dict("target_name_2")

# Блок маршрутов для target1
target1:
    # Маршрут 1: поле id из источника обрабатывается функцией s1 
    # и записывается в поле external_id с типом str
    [id] -> |*s1| -> [external_id](str)
    
    # Маршрут 2: поле name обрабатывается функцией lower
    # и записывается в поле low_name с типом str
    [name] -> |*lower| -> [low_name](str)
    
    # Функция с проверкой возраста
    [age] -> |*check_age| -> [age](int)

# Блок маршрутов для target2
target2:
    # Прямое копирование поля id
    [id] -> |id| -> [id](str)
    
    # Последовательное применение функций s1 и upper
    [name] -> |*s1|*upper| -> [name](str)
    
    # Пустое поле - генерация случайного числа
    [] -> |*gen_rand_int| -> [score](int)
    [] -> |*gen_rand_int| -> [score2](int)
```

## Расширение функциональности

### Добавление новых типов токенов

1. Добавьте новый тип в `TokenType`:

```python
class TokenType(Enum):
    # Существующие типы...
    NEW_TOKEN_TYPE = auto()  # Новый тип токена
```

2. Добавьте регулярное выражение в `PATTERNS`:

```python
PATTERNS = {
    # Существующие шаблоны...
    TokenType.NEW_TOKEN_TYPE: r'ваше_регулярное_выражение',
}
```

3. Обновите метод `tokenize()` в классе `Lexer` для обработки нового типа токена.

### Добавление новых типов узлов AST

1. Добавьте новый тип в `NodeType`:

```python
class NodeType(Enum):
    # Существующие типы...
    NEW_NODE_TYPE = auto()  # Новый тип узла
```

2. Создайте новый класс узла, наследующийся от `ASTNode`:

```python
@dataclass
class NewNodeType(ASTNode):
    # Свойства узла...
    node_type: NodeType = NodeType.NEW_NODE_TYPE
    
    def accept(self, visitor):
        return visitor.visit_new_node_type(self)
```

3. Добавьте метод `visit_new_node_type()` в класс `ASTVisitor` и реализуйте его в `JSONGenerator`.

### Добавление новых элементов конвейера

1. Добавьте новый тип в `PipelineItemType`:

```python
class PipelineItemType(Enum):
    # Существующие типы...
    NEW_PIPELINE_ITEM = "new_pipeline_item"  # Новый тип элемента
```

2. Обновите метод `_parse_pipeline()` в классе `Parser` для обработки нового типа элемента.

3. Добавьте условие в метод `accept()` класса `PipelineItemNode` и соответствующий метод визита в `JSONGenerator`.

### Добавление поддержки новых источников данных

1. Создайте новый класс стратегии, наследующийся от `DataSourceStrategy`:

```python
class NewSourceStrategy(DataSourceStrategy):
    def read_field(self, field_name, data):
        # Реализация чтения данных из нового источника
        pass
```

2. Обновите фабрику стратегий в основном коде для возврата новой стратегии при необходимости.

## Пример расширения: добавление условных операторов

Для добавления поддержки условных операторов вида `if (условие) : (иначе)`:

1. Обновить Лексер для распознавания условий:

```python
PATTERNS[TokenType.CONDITION] = r'if\s*\(([^)]*)\)\s*:\s*\(([^)]*)\)'
```

2. Обновить Парсер для создания узлов условий:

```python
def _parse_condition(self, condition_str):
    # Парсинг условия и создание соответствующего узла
    pass
```

3. Обновить JSONGenerator для обработки условий:

```python
def visit_condition(self, node):
    # Обработка условного оператора
    pass
```

## Заключение

DataRoute Parser представляет собой гибкую и расширяемую систему для работы с DSL маршрутизации данных.
Архитектура системы основана на паттернах Visitor, Strategy и Composite, что обеспечивает ее модульность
и адаптируемость к новым требованиям.

Для расширения функциональности рекомендуется следовать принципам SOLID и добавлять новые компоненты,
минимально изменяя существующий код.
