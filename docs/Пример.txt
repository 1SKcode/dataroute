# СИНТАКСИС:
[TESTS][realized] description

[+][+] source = {str}   - тип источника откуда идут данные (сейчас доступен только dict, в будущем list и чтение напрямую из БД)
[+][+] target{int}      - конечные точки куда будут записываться данные. Для каждого тaргета определяется свой route_map
[+][+] route_map       - область определения карты маршрута.
[+][+] [name] ->        - чтение индекса из source
[+][+] [] ->             - вместо чтения из source взять None  (void поле)
[+][+] -> [name](type)  - запись в target и пердвартиельныфй каст в указанный тип (при ошибке вызывается ROLLBACK(str))
[+][+] -> []            - не записывать
[][+] -> [$name](type) - записать в локальную переменную 
[+][+] |||||            - Пайплайн обработка
[+][+] *f_name          - вызов ф-ии (автоматически передается аргумент)
[+][+] *f_name()        - вызов ф-ии с аргументами (в дополнение к первому)
[+][+] $                - обращение к локальной переменной source ([name] >) внутри карты маршрута
[+][+] $this            - обращение к самому себе (на своем route)
[+][+] $$               - обращение к глобальным константам из папки variables (обращение к переменным через точку)
[][+] IF(exp): ... ELSE: ...  - Условная конструкция. Чтобы обратиться к текущей переменной используйте $this. К локальной: $name. К глобальной $$name.name (точечная нотация пол коллекции)
[][+] IF (None): (ELSE) - Если None, то выполнить ф-ию или вызвать событие (опт. иначе выполнить ф-ию или вызвать событие)
[][+] IF (in $var) (ELSE)     - Если есть вхождение, то выполнить ф-ию или вызвать событие (опт. иначе выполнить ф-ию или вызвать событие)
[][+] IF (not in $var) (ELSE) - Если нет вхождения, то выполнить ф-ию или вызвать событие (опт. иначе выполнить ф-ию или вызвать событие)
[][+] ROLLBACK(str)    - Событие: отмена всего процесса от начала до конца + NOTIFY(сообщение почему так вышло)
[][+] SKIP(str)        - Событие: пропускаем одну запись, записываем в счетчик + NOTIFY(сообщение почему так вышло)
[][+] NOTIFY(str)      - Событие: отправляем в стек уведомления

==============================================================

# АНАЛИЗАТОР-ОШИБКИ:
[TESTS][realized] description

[+][+] Нет символа направления
[+][+] Закрывающая прямая черта пайплайна не найдена
[+][+] Квадратная скобка определения сущности не найдена
[+][+] Финальный тип не задан или задан некорректно
[+][+] Для пустого поля [] нельзя указывать тип
[+][+] Неверный синтаксис определения источника
[+][+] Неверный синтаксис определения цели
[+][+] Нет определения для цели
[+][+] Пустой пайплайн обнаружен
[+][+] Неожиданный токен в коде
[+][+] Неверный тип данных
[+][+] Дублирующееся имя переменной
[+][+] Нельзя записывать во внешнюю переменную
[+][+] Дублирующееся имя цели
[+][+] Переменная не определена в текущем контексте
[+][+] Некорректное использование переменной
[+][+] Поле из левой части нельзя использовать как переменную
[+][+] Папка с внешними переменными не найдена
[+][+] Путь не найден во внешней переменной
[+][+] Файл с внешними переменными не найден
[+][+] В выражении может быть только if, но не может быть else без if
[+][+] Условная конструкция должна содержать знак скобок
[+][+] Не найдено логическое выражение внутри условной конструкции
[+][+] Не найден знак завершения условного выражения (:)
[+][+] Недопустимое или неправильное условное выражение
[+][+] Папка с пользовательскими функциями не найдена
[+][+] Пользовательская функция уже определена в системной библиотеке
[+][+] Функция не найдена
[+][+] Предупреждение: прямое отображение без звёздочки
[+][+] Нет ни одного маршрута
[+][+] Маршрут для несуществующей цели
[+][+] Дублирующееся имя целевого блока
[+][+] Дублирующееся имя цели 
[+][+] Попытка записи во внешнюю переменную
[+][+] Попытка записи в глобальную переменную
[+][+] Не опеределена глобальная переменная
----ROUTE MAP----
point:
    source[i] - route[i] - target[i](type)





ВХОДНАЯ СТРОКА:
"""
source=dict/my_dict
norm=postgres/norm_data.norm_blocks
$block9Floor=f49f5e6b-67f1-4596-a4f8-5f27f1f5f457
norm:                
    [is_euro] -> |*s1|IF($this IN $$mv.is_euro): *get(True) ELSE: *get(False)| -> [is_euro](bool)
    [rooms] -> |*s1|IF($block_uuid == $block9Floor AND $this == "9" OR $this == None): *get(0)| -> [rooms](str)
    [] -> |*get("Свободна")| -> [status](str)
    [section] -> |*s1|IF($this == None): *get("Нет секции")| -> [section_name](str)
    [price_sale] -> |*s1| -> [$price_sale](int)
    [price_base] -> |*s1|IF($price_sale != None OR $price_sale != "0"): *get($price_sale)| -> [price](int)
    [type] -> |*get_tag_by_type($this)| -> [tags](str)
    [area_total] -> [area_total](float)
    [area_given] -> [area_given](float)
    [area_kitchen] -> [area_kitchen](float)
    [number] -> |IF($this == None): *get("-")| -> [number](str)                
    [windows] -> [windows](str)
    [window_view] -> [window_view](str)
    [view_places] -> [view_places](str)
    [floor] -> |*s1|IF($this == None): *get(0)| -> [floor_of_flat](int)   
    [floors_in_section] -> [floors_in_section](int)
    [comment] -> [comment](str)
    [plan_url] -> [plan_url](str)
    [floor_plan_url] -> [floor_plan_url](str)
    [finising] -> |*get_finishing($this)| -> [finishing](str)
    [uuid] -> [flats_uuid](str)
    [] -> |*get_flats_type_uuid($block_uuid, $rooms, $tags)| -> [flats_type_uuid](str)
    [building_uuid] -> [building_uuid](str)
    [block_uuid] -> [block_uuid](str)
    [] -> |*get_uuid_real_estate_type($tags)| -> [uuid_real_estate_type](str)

"""

СЛОВАРЬ ПОСЛЕ ПАРСИНГА:






давай тут сдлеаем универсальный асинхронный конструктор ETL процесса!

На вход может подаваиться json с инструкциями по выполнению
А мы должны на этом построить ETL

Примеры валидных json вот тут:
@test_base_syntax.py 

Пайплайны будут работать на @pydantic 
И выполняться асинхронно, но не все сразу, а опираясь на инструкцию в ключе execution_plan

В будущем добавиться возможность различных типов нотификации если что-то происходит не то во время выполенния
Напрмиер будет модуль ТГ уведомлденгий (это потом)
Папкка нотификаторов: @notifiers 
Сейчас для простоты будет только один: @console_notifier.py он просто пишет в консоль там где и выполянется код

Написанный внутренний проект сначала на вход получает json
Он заходит в первый ключ и ищет ключ source_type. Далее понимаем каким методом нам брать данные (у нас есть папка @source_getters в которой лежат файлы для работы с источником)
Для простоты сначала будем работать просто с источником 
@pydict_source_getter.py

А записывать будем в @target_writers  и там я уже создал @pg_target_writer.py (там в будущем будет осуществляться запись в постгрес через asyncpg)

Теперь к главному файлу: @dtrt_runner.py он как раз таки и будет принимать в себя аргументы:
1. json структуру с инструкциями
2. пользовательская папка с перменными
3. пользовательская папка с ф-иями
4. notifier (у нас сейчас только "console")
5. source_data (opt)(это полезные данные, которые будут участоваать ккак источник)
6. Данные для подключения к БД

Далее он открывает, смотрит какой там указан source_type
В зависимости от source_type он выбирает объект какого класса выбрать в @source_getters (сейчас там всего один) 
Ксати посмотри его, я реализовал
Для всех мэтчингов нужно использовать файл@config.py 
При создании передаем два аргумента: 1. непосредственно наш словарь. 2. поля, которые нужно забрать (их берем из execution_plan или можно пройтись по json собрать, тут как удобнее)
Далее мы обращзаемся к созданному объекту класса 
через getter.report
получаем что-то по типу такого: 
{'fully_valid': False,
 'invalid_count': 18,
 'invalid_examples': [{'index': 0, 'missing_keys': ['age']},
                      {'index': 3, 'missing_keys': ['age']},
                      {'index': 4, 'missing_keys': ['name']},
                      {'index': 9, 'missing_keys': ['age']},
                      {'index': 12, 'missing_keys': ['name']},
                      {'index': 14, 'missing_keys': ['age']},
                      {'index': 18, 'missing_keys': ['age']},
                      {'index': 20, 'missing_keys': ['age']},
                      {'index': 22, 'missing_keys': ['name']},
                      {'index': 25, 'missing_keys': ['age']}],
 'percent_valid': 63.265,
 'source': 'pydict',
 'total_received': 49,
 'valid_count': 31}

Если видим, что 'fully_valid': False, то вызываем созданное в @exeptions.py исключение и выводим аккуратно в консоль через @console_notifier.py . + завершаем выполнение

Если видим fully_valid истиным, то переходим к валидации полей в нашем уже таргете:
В зависимости от того какое значениее в target_type, мы выбираем способ работы в @target_writers создаем врайтера и просим у него метод валидации полецй (если нужно передаем строки для подключения если они есть)
Он тоже должен вернуть ответ, все ли поля (final_name) есть в таргете

Затем переходим к формированию пайплайнов!!
И тут достаточно сложная конечно задача. Но за ее выполнение ты получишь награду!
Опять же, смотри на всевозможные входные json в @test_base_syntax.py 

Обрати внимание, что ты должен построить пайплайн по иснтукциям
А потом запустить асинхронно опираясь на execution_plan!
Если что, можешь создать файлы необходимые, если посчитаешь нужным разделить логику по файлам

Данные должны преобразовываться согласно этим инстукциям
В том числе условыне конструкции должны соблюдаться 
Для удобвства я сделал для тебя так что в блоках exp в ключе full_str ты можешь по сути преобразовать это в пайтон код и посмотреть что там True или False

Так же для удобства я сделал для тебя такую строку для передачи параметров в python ф-ию там есть ключ param
Кстати по поводу того откуда брать ф-ии: у нас есть встроенные ф-ии в папке @std_func нужно смотреть их оттуда. А так же мы уазывали путь к пользовательским функциям. Например вот тут мои @my_funcs 
Валидировать их существование не нужно. Если они указаны в json, значит они точно есть!
Ф-ии у меня всегда вида: def func(*args, **kwargs): и всегда ретернят значения

$this - это грубо говоря перменная этого пайплайна (ОНА ИЗМЕНЯЕТСЯ ПО ХОДУ ВОЗВРАЩЕНИЯ ИЗ Ф-ИЙ)

Посде того как пайплайн отработал до конца мы добавлем его значенеи в значение финального словаря!
Ключ этого финального словаря - это название из final_name
А значение - то что вышло у нас ну и понятно, что туда попадает уже из pydentyc и по хорошему должны быть в своем типе нужном уже, но в дальнейшем это все равно у нас будет проверяться

Финальный словарь - это составной словарь вида:
final_frame = {
    'final_name': {
        'source_name': 'name',
        'final_type': 'str',
        'final_value': 'var'
    }

По поводу того, что ты увидишь $name в аргументах и в выражениях условных. Тут все просто - подставляешь значение из 
final_frame словаря. Там будет мэтчинг $text1 = text1 (его и ищем в final_name) затем обязательо кастуем final_value в final_type и уже передаем его в ф-ию. Результат должен передаваться дальше по пайплайну

Если встретишь:
  "type": "event",
                "sub_type": "NOTIFY",
                "param": "\"Прсто уведомление\"",
                "full_str": "NOTIFY(\"Прсто уведомление\")"
              }
То это тип события означает, что нужно что-то сделдать сейчас и обязхательно отправитть сообщение через выбранный на данный момоент @notifiers 
NOTIFY - означает ничего не делать, просто отправь сообщение
SKIP - отмени весь final_frame и перейди к следующему листу данных  Ну и все так же отправь сообщение через выбранный на данный момоент 
ROLLBACK - отмени вообще все! И отправь сообщение

Напомню о том, что асинхронное выполненеи идет согласно execution_plan, чтобы не попоась на ситуацию, когда мы взяли на выполнение то, что имеет зависимость в аргументах от другой перменной
Поэтому мы выполянем по мере зависимостей, чтобы в final_frame всгда находились нужные даненые

КОгда мы выполнились и все асинхронности положили свои данные в final_frame, то кладем этот final_frame в более глобальную штуку - warehouse это лист таких словарей
Тут важен порядок, ведь мы будем вставлять потом из этого слдоваря в наш намеченный таргет


После того как мы прошли по всем словарям в листе и собрали готовый final_frame и прошлись по ним всем, заполнив тем самым warehouse, мы понимаем, что т.к все свалидированно и знаем что поля для записи сущесвтуют благодрая прошлой проверки @target_writers то мы можем вызвать уже ранее созданнывй объект от @target_writers, передать в него наш warehouse и запустить запись через asyncpg!!

Сделай все чисто, как будто ты старший разработчик!
Срарайся разбивать на блоки. Проверять себяч кажддый раз

